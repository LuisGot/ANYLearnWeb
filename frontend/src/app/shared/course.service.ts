import { computed, Injectable, signal } from '@angular/core';

@Injectable({
  providedIn: 'root',
})
export class CourseService {
  isLoading = signal(false);
  course = signal<{ subtopic: string; content: string }[]>([
    {
      subtopic: 'Introduction to FastAPI',
      content:
        '## Introduction to FastAPI\n### Introduction\nFastAPI is a modern, fast (high-performance), web framework for building APIs with Python 3.7+ based on standard Python type hints. It is designed to be fast, robust, and easy to use, making it an ideal choice for building APIs. FastAPI provides a lot of features out of the box, including automatic API documentation, strong typing, and support for asynchronous programming.\n\n### Detailed Explanation\nFastAPI was created by Sebastián Ramírez, and it has been gaining popularity due to its ease of use, flexibility, and speed. FastAPI is built on top of standard Python type hints using Python 3.7+ and is based on the ASGI specification, which allows it to run on ASGI servers such as uvicorn. One of the key features of FastAPI is its support for asynchronous programming, which makes it ideal for building high-performance APIs.\n\nSome of the key benefits of using FastAPI include:\n\n* **Fast**: FastAPI is designed to be fast, with performance comparable to Node.js and Go.\n* **Robust**: FastAPI provides a lot of features out of the box, including support for automatic API documentation, strong typing, and error handling.\n* **Easy to use**: FastAPI has a simple and intuitive API, making it easy to use and learn.\n* **Strongly typed**: FastAPI uses Python type hints to provide strong typing, which helps catch errors at runtime.\n\nHere is a simple example of a FastAPI application:\n```python\n# Import the FastAPI class\nfrom fastapi import FastAPI\n\n# Create a new FastAPI application\napp = FastAPI()\n\n# Define a route for the root URL\n@app.get("/")\ndef read_root():\n    # Return a JSON response\n    return {"Hello": "World"}\n```\nThis example demonstrates how to create a new FastAPI application and define a route for the root URL. The `read_root` function returns a JSON response with a greeting.\n\n### Practical Exercise\nTo get started with FastAPI, follow these steps:\n\n1. **Install FastAPI and uvicorn**: You can install FastAPI using pip: `pip install fastapi uvicorn`\n2. **Create a new FastAPI application**: Create a new file called `main.py` and add the following code:\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get("/")\ndef read_root():\n    return {"Hello": "World"}\n```\n3. **Run the application**: Run the application using uvicorn: `uvicorn main:app --reload`\n4. **Test the application**: Open a web browser and navigate to `http://localhost:8000/` to see the JSON response.\n\nBy following these steps, you can create a simple FastAPI application and test it using a web browser. This exercise demonstrates how to get started with FastAPI and how to define a simple route for the root URL.',
    },
    {
      subtopic: 'Setting Up a FastAPI Project',
      content:
        '## Setting Up a FastAPI Project\n### Introduction:\nSetting up a FastAPI project is the initial step in building web applications with FastAPI, a modern, fast (high-performance), web framework for building APIs with Python 3.7+ based on standard Python type hints. This section will guide you through creating a new FastAPI project, explaining the process and best practices for setting up your development environment. FastAPI projects are typically set up using the command line interface (CLI) and a tool like `pip` for package management.\n\n### Main Content:\n#### Step 1: Install FastAPI and uvicorn\nTo start a new FastAPI project, you first need to install FastAPI and a server to run it. `uvicorn` is a popular choice for serving FastAPI applications because it supports async/await and HTTP/1.1 and WebSockets out of the box.\n\n```python\n# Install FastAPI and uvicorn using pip\npip install fastapi uvicorn\n```\n\n#### Step 2: Create Your Project Directory\nNext, create a new directory for your project. This will keep your project files organized.\n\n```bash\n# Create a new directory named myfastapi\nmkdir myfastapi\n# Navigate into the new directory\ncd myfastapi\n```\n\n#### Step 3: Initialize a New Python Project\nIt\'s a good practice to initialize your project as a Python package. This makes it easier to manage dependencies and structure your code.\n\n```bash\n# Create a new virtual environment (Recommended)\npython -m venv venv\n# Activate the virtual environment\n# On Windows\nvenv\\Scripts\\activate\n# On Unix/Linux/MacOS\nsource venv/bin/activate\n```\n\n#### Step 4: Create Your FastAPI App\nInside your project directory, create a file named `main.py`. This file will contain the basic structure of your FastAPI application.\n\n```python\n# main.py\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get("/")\ndef read_root():\n    return {"Hello": "World"}\n```\n\n#### Step 5: Run Your FastAPI App\nWith `uvicorn`, you can run your FastAPI application. Use the following command:\n\n```bash\n# Run the FastAPI application\nuvicorn main:app --reload\n```\n\nThe `--reload` flag tells `uvicorn` to automatically restart the server if it detects any changes in your code.\n\n### Exercise:\nNow that you\'ve set up your first FastAPI project, try modifying the `main.py` file to add another endpoint. For example, create an endpoint `/items/` that returns a list of items. \n\n1. Modify `main.py` to include a new endpoint:\n    ```python\n    from fastapi import FastAPI\n\n    app = FastAPI()\n\n    items = [{"name": "Item1"}, {"name": "Item2"}]\n\n    @app.get("/")\n    def read_root():\n        return {"Hello": "World"}\n\n    @app.get("/items/")\n    def read_items():\n        return items\n    ```\n2. Run your application again using `uvicorn main:app --reload`.\n3. Use a tool like `curl` or a web browser to visit `http://127.0.0.1:8000/items/` and see the list of items returned.\n\nThis exercise helps you understand how to structure your application, work with endpoints, and handle simple data in FastAPI. Remember, practice makes perfect, so don\'t be afraid to experiment and try new things!',
    },
    {
      subtopic: 'Understanding FastAPI Routes',
      content:
        '## Understanding FastAPI Routes\n### Introduction:\nFastAPI routes are a fundamental concept in building web applications using the FastAPI framework. They define the structure and behavior of how the application responds to different HTTP requests. Understanding FastAPI routes is essential for designing and implementing scalable, efficient, and maintainable web services.\n\n### Detailed Explanation:\nIn FastAPI, routes are used to map specific URL paths to particular functions or methods within the application. These functions are responsible for handling the logic behind each route, including processing requests, accessing databases, and returning responses. The key aspects of FastAPI routes include:\n\n* **Path Parameters:** These are values passed in the URL path. For example, in a route defined as `/users/{user_id}`, `user_id` is a path parameter.\n* **Query Parameters:** These are key-value pairs passed in the URL query string. For example, in a route like `/items/?skip=0&limit=10`, `skip` and `limit` are query parameters.\n* **Request Body:** Data sent with the request, typically used in POST, PUT, and PATCH methods, can be processed using models defined with Pydantic.\n* **HTTP Methods:** FastAPI supports standard HTTP methods such as GET, POST, PUT, DELETE, etc., each serving different purposes in interacting with resources.\n\n```python\n# Example of defining a route with path parameters\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get("/users/{user_id}")\ndef read_user(user_id: int):\n    return {"user_id": user_id}\n```\n\n```python\n# Example of handling query parameters\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get("/items/")\ndef read_items(skip: int = 0, limit: int = 10):\n    return {"skip": skip, "limit": limit}\n```\n\n* **Route Order Matters:** FastAPI evaluates routes in the order they are defined. It\'s crucial to define more specific routes before less specific ones to avoid unintended behavior.\n* **Using Route Guards:** FastAPI provides features like dependencies and middleware that can act as route guards, enabling you to add authentication, logging, or other functionalities to your routes.\n\n### Practical Exercise:\nCreate a simple FastAPI application that includes routes for creating, reading, updating, and deleting (CRUD) a collection of items.\n\n1. **Install FastAPI and Uvicorn:** If you haven\'t already, install FastAPI and Uvicorn using pip: `pip install fastapi uvicorn`.\n2. **Create the Application:** Create a new file named `main.py` and define your FastAPI application within it.\n\n```python\n# Language: Python\nfrom fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n# Define a model for the items\nclass Item(BaseModel):\n    id: int\n    name: str\n    description: str\n\n# In-memory item collection for simplicity\nitems = [\n    {"id": 1, "name": "Item 1", "description": "Description for Item 1"},\n    {"id": 2, "name": "Item 2", "description": "Description for Item 2"},\n]\n\n# Route for getting all items\n@app.get("/items/")\ndef read_items():\n    return items\n\n# Route for getting an item by ID\n@app.get("/items/{item_id}")\ndef read_item(item_id: int):\n    for item in items:\n        if item["id"] == item_id:\n            return item\n    raise HTTPException(status_code=404, detail="Item not found")\n\n# Route for creating a new item\n@app.post("/items/")\ndef create_item(new_item: Item):\n    items.append(new_item.dict())\n    return new_item\n\n# Route for updating an existing item\n@app.put("/items/{item_id}")\ndef update_item(item_id: int, updated_item: Item):\n    for item in items:\n        if item["id"] == item_id:\n            item["name"] = updated_item.name\n            item["description"] = updated_item.description\n            return item\n    raise HTTPException(status_code=404, detail="Item not found")\n\n# Route for deleting an item\n@app.delete("/items/{item_id}")\ndef delete_item(item_id: int):\n    for item in items:\n        if item["id"] == item_id:\n            items.remove(item)\n            return {"message": "Item deleted successfully"}\n    raise HTTPException(status_code=404, detail="Item not found")\n```\n\n3. **Run the Application:** Use Uvicorn to run your application: `uvicorn main:app --reload`.\n4. **Test the Routes:** Use a tool like curl or Postman to test your CRUD routes. For example, to get all items, you can use `curl http://127.0.0.1:8000/items/`.',
    },
    {
      subtopic: 'Creating Simple Endpoints',
      content:
        '## Creating Simple Endpoints\n### Introduction:\nCreating simple endpoints is a fundamental step in building a FastAPI application, as it allows developers to define how their application interacts with clients. Endpoints are the URLs that clients can use to access the application\'s functionality. In this section, we will explore how to create simple endpoints in FastAPI.\n\n### Main Content:\nFastAPI is designed to be fast, robust, and easy to use, and creating endpoints is one of its core features. Endpoints in FastAPI are created using Python functions decorated with the `@app` object, typically `@app.get()`, `@app.post()`, `@app.put()`, or `@app.delete()` for different HTTP methods.\n\n#### Basic Endpoint Structure\nThe basic structure of an endpoint in FastAPI looks like this:\n```python\n# Import FastAPI\nfrom fastapi import FastAPI\n\n# Create a FastAPI application\napp = FastAPI()\n\n# Create a simple endpoint\n@app.get("/")\ndef read_root():\n    return {"Hello": "World"}\n```\nIn this example, `@app.get("/")` defines an endpoint at the root URL (`"/"`) of the application that responds to GET requests. The function `read_root()` is executed when this endpoint is accessed, and it returns a JSON response.\n\n#### Creating Endpoints for Different HTTP Methods\nFastAPI supports various HTTP methods for creating endpoints:\n- **GET**: Used for retrieving data. Decorated with `@app.get()`.\n- **POST**: Used for creating new data. Decorated with `@app.post()`.\n- **PUT**: Used for updating existing data. Decorated with `@app.put()`.\n- **DELETE**: Used for deleting data. Decorated with `@app.delete()`.\n\nHere is an example of creating endpoints for these methods:\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n# GET endpoint\n@app.get("/items/")\ndef read_items():\n    return [{"name": "Item1"}, {"name": "Item2"}]\n\n# POST endpoint\n@app.post("/items/")\ndef create_item(item: dict):\n    return item\n\n# PUT endpoint\n@app.put("/items/{item_id}")\ndef update_item(item_id: int, item: dict):\n    return {"item_id": item_id, "item": item}\n\n# DELETE endpoint\n@app.delete("/items/{item_id}")\ndef delete_item(item_id: int):\n    return {"item_id": item_id, "message": "Item deleted"}\n```\n#### Path Parameters\nFastAPI also supports path parameters, which allow you to pass variables in the URL path. You can define path parameters in the endpoint path using curly braces `{}`. Here\'s an example:\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get("/items/{item_id}")\ndef read_item(item_id: int):\n    return {"item_id": item_id}\n```\nIn this example, `item_id` is a path parameter that is passed to the `read_item` function.\n\n### Exercise:\nCreate a simple FastAPI application with endpoints for the following:\n1. A GET endpoint at `/` that returns a welcome message.\n2. A POST endpoint at `/create-item` that creates a new item and returns it.\n3. A PUT endpoint at `/update-item/{item_id}` that updates an existing item and returns the updated item.\n\nUse the following Python code as a starting point:\n```python\nfrom fastapi import FastAPI\napp = FastAPI()\n```\nAdd the necessary endpoints and logic to complete the task.\n\n### Note:\nLanguage used in markdown code block: **Python**. Ensure you follow the instructions precisely and create a fully functional FastAPI application that meets the requirements outlined in the exercise.',
    },
    {
      subtopic: 'Working with JSON Data in FastAPI',
      content:
        '## Working with JSON Data in FastAPI\n### Introduction\nWorking with JSON data is a crucial aspect of building RESTful APIs, as it is the most commonly used data format for exchanging information between web servers and web applications. FastAPI, being a modern, fast (high-performance), web framework for building APIs with Python 3.7+ based on standard Python type hints, provides robust support for working with JSON data.\n\n### Detailed Explanation\nJSON (JavaScript Object Notation) is a lightweight data interchange format that is easy to read and write. It is language-independent and is widely used for data exchange between a server and a client. In the context of FastAPI, JSON data is used to send and receive data from the client side. \n\nTo work with JSON data in FastAPI, you primarily use the `request` and `response` objects. \n\n- **Sending JSON Data:** When a client sends a request to the server with JSON data, FastAPI automatically parses the JSON data and stores it in the `request` object. You can access the JSON data using the `request.json()` method.\n\n- **Receiving JSON Data:** When the server needs to send data back to the client, it can be done using the `response` object. FastAPI supports returning JSON data directly from the endpoint functions.\n\nHere are some key concepts to keep in mind when working with JSON data in FastAPI:\n\n*   **JSON Encoding and Decoding:** FastAPI uses the `json` module under the hood to encode and decode JSON data. This makes it seamless to work with JSON data without worrying about the intricacies of JSON encoding and decoding.\n\n*   **Data Validation:** When receiving JSON data from the client, it\'s crucial to validate the data to ensure it conforms to the expected format and structure. FastAPI integrates well with Pydantic models for data validation, making it a powerful tool for ensuring data integrity.\n\n*   **Error Handling:** When working with JSON data, errors can occur due to malformed JSON, missing fields, or invalid data types. FastAPI provides excellent support for error handling, allowing you to catch and handle exceptions gracefully.\n\n### Example Code\nHere is an example of how to send and receive JSON data in FastAPI:\n\n```python\n# Import FastAPI and define the application\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n# Define a Pydantic model for data validation\nclass Item(BaseModel):\n    id: int\n    name: str\n    description: str\n\n# Define an endpoint to receive JSON data\n@app.post("/items/")\nasync def create_item(item: Item):\n    # Access the JSON data\n    item_dict = item.dict()\n    \n    # Process the data\n    print(f"Received item: {item_dict}")\n    \n    # Return a response\n    return {"message": "Item created successfully"}\n\n# Define an endpoint to send JSON data\n@app.get("/items/")\nasync def read_items():\n    # Sample data\n    items = [\n        {"id": 1, "name": "Item 1", "description": "This is item 1"},\n        {"id": 2, "name": "Item 2", "description": "This is item 2"}\n    ]\n    \n    # Return JSON data\n    return items\n```\n\nIn this example, we define two endpoints: one to receive JSON data using the `create_item` function and another to send JSON data using the `read_items` function.\n\n### Practical Exercise\nCreate a FastAPI application with an endpoint that accepts JSON data with a name and age, validates the data using Pydantic, and returns a greeting message with the name and age.\n\n```python\n# language: python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass Person(BaseModel):\n    name: str\n    age: int\n\n@app.post("/greet/")\nasync def greet(person: Person):\n    return {"message": f"Hello, {person.name}! You are {person.age} years old."}\n```\n\nTo test the endpoint, send a POST request with JSON data:\n\n```json\n{\n    "name": "John Doe",\n    "age": 30\n}\n```\n\nYou should receive a response with a greeting message:\n\n```json\n{\n    "message": "Hello, John Doe! You are 30 years old."\n}\n```',
    },
    {
      subtopic: 'Defining Request and Response Models',
      content:
        '# Defining Request and Response Models\n## Introduction\nDefining request and response models is a crucial aspect of building robust and maintainable APIs with FastAPI. These models help in structuring the data that is sent and received by the API, ensuring clarity and consistency in communication between the client and server. By using models, developers can take advantage of automatic documentation, validation, and serialization/deserialization of data.\n\n## Detailed Explanation\nIn FastAPI, request and response models are typically defined using Pydantic models. Pydantic is a Python library for building robust, scalable, and fast data validation and parsing. It provides a simple and intuitive way to define data models, which can then be used to validate and parse data.\n\n### Key Concepts\n- **Request Models**: These are used to define the structure of the data that is expected to be received by the API. For example, when creating a new user, the request model would define the fields that are required (like `username`, `email`, and `password`) and their data types.\n- **Response Models**: These define the structure of the data that the API will return in response to a request. This could include the data that was requested, along with any additional metadata.\n\n### Defining Models with Pydantic\nTo define a model, you import `BaseModel` from `pydantic` and create a class that inherits from it. Here is a simple example of how to define a request model for creating a new user:\n\n```python\n# Language: Python\nfrom pydantic import BaseModel\n\nclass UserCreate(BaseModel):\n    username: str\n    email: str\n    password: str\n```\n\nAnd here\'s how you might define a response model for the same user:\n\n```python\n# Language: Python\nfrom pydantic import BaseModel\n\nclass UserResponse(BaseModel):\n    id: int\n    username: str\n    email: str\n\n    class Config:\n        orm_mode = True\n```\n\nNote the use of `orm_mode = True` in the response model. This is particularly useful when working with databases using an ORM (Object Relational Mapping) tool like SQLAlchemy or Tortoise ORM, as it allows the model to work seamlessly with ORM objects.\n\n### Using Models in FastAPI Endpoints\nOnce you have defined your request and response models, you can use them directly in your FastAPI endpoint definitions. FastAPI will automatically use these models for validation, serialization, and documentation.\n\nFor example, using the `UserCreate` model as a request body model in an endpoint:\n\n```python\n# Language: Python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass UserCreate(BaseModel):\n    username: str\n    email: str\n    password: str\n\n@app.post("/users/")\nasync def create_user(user: UserCreate):\n    # Here you would typically save the user to the database\n    # For demonstration purposes, we\'ll just return the user\n    return user\n```\n\nAnd using the `UserResponse` model as a response model:\n\n```python\n# Language: Python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass UserResponse(BaseModel):\n    id: int\n    username: str\n    email: str\n\n    class Config:\n        orm_mode = True\n\n@app.get("/users/{user_id}", response_model=UserResponse)\nasync def read_user(user_id: int):\n    # Fetch the user from the database\n    # For demonstration purposes, let\'s assume we have a function `get_user` that does this\n    user = get_user(user_id)\n    return user\n```\n\n## Practical Exercise\nDesign and implement a simple API endpoint using FastAPI that accepts a `TodoItem` model as a request body. The `TodoItem` model should have fields for `id`, `title`, and `done`. Use Pydantic to define the `TodoItem` model and ensure that FastAPI uses it for validation and documentation.\n\n1. Define the `TodoItem` model using Pydantic.\n2. Create a FastAPI endpoint at `/todo/` that accepts POST requests with a `TodoItem` in the request body.\n3. In the endpoint, validate the received `TodoItem` and return it back as a response.\n4. Use the `response_model` parameter in the endpoint decorator to specify the response model.\n\nExample Solution:\n\n```python\n# Language: Python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass TodoItem(BaseModel):\n    id: int\n    title: str\n    done: bool\n\n@app.post("/todo/", response_model=TodoItem)\nasync def create_todo(todo: TodoItem):\n    # For this example, we\'re just returning the todo item\n    # In a real application, you\'d typically save it to a database\n    return todo\n```\n\nThis exercise demonstrates how to define request and response models using Pydantic and integrate them with FastAPI endpoints for robust data validation and parsing.',
    },
    {
      subtopic: 'Handling Requests and Responses',
      content:
        '## Handling Requests and Responses\n### Introduction\nHandling requests and responses is a fundamental aspect of building web applications with FastAPI, as it enables the creation of robust, scalable, and maintainable APIs. This subtopic delves into the mechanisms and best practices for managing incoming requests and outgoing responses, ensuring that your FastAPI application can efficiently communicate with clients and provide the desired data or services. Properly handling requests and responses is crucial for developing a well-structured and reliable API.\n\n### Detailed Explanation\nFastAPI provides a comprehensive set of tools and features for handling requests and responses, making it easier to build high-performance APIs. The following key concepts, definitions, and principles are essential for understanding and implementing effective request and response handling in FastAPI:\n\n*   **Requests:** In FastAPI, requests are represented by the `Request` object, which contains information about the incoming HTTP request, such as the method (GET, POST, PUT, DELETE, etc.), headers, query parameters, and body.\n*   **Responses:** FastAPI uses the `Response` object to represent HTTP responses. You can create custom responses using the `Response` constructor or use the `JSONResponse` class for JSON data.\n*   **Path Parameters:** FastAPI supports path parameters, which allow you to pass variables as part of the URL path. You can define path parameters using curly braces `{}` in your route paths.\n*   **Query Parameters:** Query parameters are used to pass data in the URL query string. FastAPI provides the `Query` parameter annotation to handle query parameters.\n*   **Request Body:** FastAPI supports parsing request bodies in various formats, including JSON, form data, and file uploads. You can use the `Body` parameter annotation to handle request bodies.\n\nHere\'s an example of handling a simple GET request with path parameters:\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get("/items/{item_id}")\nasync def read_item(item_id: int):\n    return {"item_id": item_id}\n```\nIn this example, the `read_item` function handles GET requests to the `/items/{item_id}` path, where `item_id` is a path parameter. The function returns a JSON response with the `item_id` value.\n\nFor handling POST requests with JSON data, you can use the `Body` parameter annotation:\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass Item(BaseModel):\n    name: str\n    description: str\n\n@app.post("/items/")\nasync def create_item(item: Item):\n    return item\n```\nIn this example, the `create_item` function handles POST requests to the `/items/` path, where the request body is expected to be a JSON object conforming to the `Item` model. The function returns the created item as a JSON response.\n\n### Practical Exercise\nCreate a FastAPI application that handles GET and POST requests for a simple todo list API. The API should have the following endpoints:\n\n*   `GET /todos`: Returns a list of all todo items\n*   `POST /todos`: Creates a new todo item with the provided JSON data\n\nUse the following `TodoItem` model to represent todo items:\n```python\nfrom pydantic import BaseModel\n\nclass TodoItem(BaseModel):\n    id: int\n    title: str\n    completed: bool\n```\nYour task is to implement the `read_todos` and `create_todo` functions to handle the respective requests. You can use a simple in-memory list to store the todo items.\n\nExample solution:\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass TodoItem(BaseModel):\n    id: int\n    title: str\n    completed: bool\n\n# In-memory todo list\ntodos = [\n    TodoItem(id=1, title="Buy milk", completed=False),\n    TodoItem(id=2, title="Walk the dog", completed=True),\n]\n\n@app.get("/todos")\nasync def read_todos():\n    return todos\n\n@app.post("/todos")\nasync def create_todo(item: TodoItem):\n    todos.append(item)\n    return item\n```\nTest your implementation by sending GET and POST requests to the `/todos` endpoint using a tool like `curl` or a REST client. Verify that the API returns the expected responses and that the todo list is updated correctly.',
    },
    {
      subtopic: ' Validating User Input with Pydantic',
      content:
        '### Validating User Input with Pydantic\n#### Introduction:\nValidating user input is a crucial aspect of building robust and secure FastAPI applications. Pydantic is a powerful library that simplifies the process of validating and parsing user input, ensuring that your application receives and processes data correctly. In this section, we\'ll delve into how to use Pydantic for validating user input in FastAPI.\n\n#### Main Content:\nPydantic provides a simple and intuitive way to define models that can be used to validate user input. By defining a Pydantic model, you can specify the expected structure and constraints of the input data, such as data types, lengths, and ranges.\n\nFor example, consider a simple `User` model that requires a `name` and an `email`:\n```python\n# Using Python\nfrom pydantic import BaseModel\nfrom typing import Optional\n\nclass User(BaseModel):\n    name: str\n    email: str\n    age: Optional[int] = None\n```\nIn this example, the `name` and `email` fields are required, while the `age` field is optional.\n\nTo validate user input against this model, you can use the `response_model` parameter in your FastAPI endpoint:\n```python\n# Using Python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass User(BaseModel):\n    name: str\n    email: str\n    age: Optional[int] = None\n\n@app.post("/users/")\nasync def create_user(user: User):\n    return user\n```\nIn this example, when a request is sent to the `/users/` endpoint, FastAPI will automatically validate the input data against the `User` model. If the input data is invalid, FastAPI will return a 422 Unprocessable Entity error with detailed information about the validation errors.\n\nYou can also use Pydantic\'s built-in validation features, such as `Regex` and `EmailStr`, to enforce more complex validation rules:\n```python\n# Using Python\nfrom pydantic import BaseModel, EmailStr, Regex\n\nclass User(BaseModel):\n    name: str\n    email: EmailStr\n    phone_number: str = Regex(r"^(\\d{3}[-\\.\\s]??\\d{3}[-\\.\\s]??\\d{4}|\\(\\d{3}\\)\\s*\\d{3}[-\\.\\s]??\\d{4}|\\d{3}[-\\.\\s]??\\d{4})$")\n```\nIn this example, the `email` field is validated against an email address pattern, while the `phone_number` field is validated against a regular expression pattern.\n\n#### Exercise:\nCreate a Pydantic model to validate a `Product` object with the following fields:\n\n* `name`: a required string field\n* `price`: a required float field with a minimum value of 0.0\n* `description`: an optional string field with a maximum length of 200 characters\n\nUse this model to validate user input in a FastAPI endpoint, and return a 422 Unprocessable Entity error if the input data is invalid.\n\n```python\n# Using Python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, ValidationError\n\napp = FastAPI()\n\nclass Product(BaseModel):\n    name: str\n    price: float = 0.0\n    description: Optional[str] = None\n\n    class Config:\n        schema_extra = {\n            "examples": [\n                {\n                    "name": "Example Product",\n                    "price": 19.99,\n                    "description": "This is an example product."\n                }\n            ]\n        }\n\n@app.post("/products/")\nasync def create_product(product: Product):\n    try:\n        return product\n    except ValidationError as e:\n        return {"error": e}\n\n# Test the endpoint with valid and invalid input data\n```\nBy completing this exercise, you\'ll gain hands-on experience with using Pydantic to validate user input in FastAPI, and you\'ll be able to apply this knowledge to build more robust and secure applications.',
    },
    {
      subtopic: 'Returning JSON Data from Endpoints',
      content:
        '## Returning JSON Data from Endpoints\n### Introduction:\nReturning JSON data from endpoints is a fundamental aspect of building RESTful APIs with FastAPI. JSON (JavaScript Object Notation) is a lightweight data interchange format that is easy to read and write, making it a popular choice for API responses. In this section, we will explore how to return JSON data from endpoints in a FastAPI application.\n\n### Main Content:\nTo return JSON data from an endpoint in FastAPI, you can simply return a Python dictionary from your endpoint function. FastAPI will automatically convert the dictionary to JSON and set the `Content-Type` header of the response to `application/json`.\n\nHere is an example of how to return JSON data from an endpoint:\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get("/items/")\ndef read_items():\n    return [{"name": "Item 1"}, {"name": "Item 2"}]\n```\nIn this example, the `read_items` function returns a list of dictionaries, which will be converted to a JSON array.\n\nYou can also use the `JSONResponse` class to return JSON data:\n```python\nfrom fastapi import FastAPI\nfrom fastapi.responses import JSONResponse\n\napp = FastAPI()\n\n@app.get("/items/")\ndef read_items():\n    return JSONResponse(content=[{"name": "Item 1"}, {"name": "Item 2"}], media_type="application/json")\n```\nHowever, using the `JSONResponse` class is not necessary in most cases, as FastAPI will automatically convert the returned data to JSON.\n\n### Exercise:\nCreate a new FastAPI endpoint that returns a JSON object with the following structure:\n```json\n{\n    "name": "John Doe",\n    "age": 30,\n    "city": "New York"\n}\n```\nUse the following code as a starting point:\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get("/person/")\ndef read_person():\n    # Return the JSON object here\n    pass\n```\nFill in the `read_person` function to return the required JSON object.\n\n### Solution:\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get("/person/")\ndef read_person():\n    return {"name": "John Doe", "age": 30, "city": "New York"}\n```\nThis will return the required JSON object when the `/person/` endpoint is accessed.\n\nNote: The language used in this markdown code block is ```python``` and ```json```.',
    },
    {
      subtopic: 'Error Handling in FastAPI',
      content:
        '## Error Handling in FastAPI\n### Introduction\nError handling is a critical component of any web application, including those built with FastAPI. It allows developers to manage and respond to exceptions, providing a better user experience and helping with debugging. In this section, we will delve into the world of error handling in FastAPI, exploring how to implement custom error handlers and use built-in features to manage errors effectively.\n\n### Detailed Explanation\nFastAPI provides several ways to handle errors, including using try-except blocks, creating custom exception handlers, and utilizing the `HTTPException` class. \n\n#### Try-Except Blocks\nTry-except blocks are a fundamental way to catch and handle exceptions in Python. In the context of FastAPI, you can use them within your endpoint functions to catch specific exceptions and return a custom response.\n\n```python\n# Example of using try-except blocks in FastAPI endpoint\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get("/items/{item_id}")\ndef read_item(item_id: int):\n    try:\n        # Code that might raise an exception\n        item = {"id": item_id, "name": "Item Name"}\n        if item_id < 0:\n            raise ValueError("Item ID must be positive")\n        return item\n    except ValueError as e:\n        return {"error": str(e)}\n```\n\n#### Custom Exception Handlers\nFastAPI allows you to define custom exception handlers using the `@app.exception_handler()` decorator. This decorator takes an exception class as an argument and a function that will handle the exception.\n\n```python\n# Example of a custom exception handler\nfrom fastapi import FastAPI, HTTPException\nfrom fastapi.responses import JSONResponse\n\napp = FastAPI()\n\n@app.exception_handler(HTTPException)\ndef http_exception_handler(request, exc):\n    return JSONResponse(status_code=exc.status_code, content={"error": exc.detail})\n\n# Example of raising an HTTPException\n@app.get("/items/{item_id}")\ndef read_item(item_id: int):\n    if item_id < 0:\n        raise HTTPException(status_code=400, detail="Item ID must be positive")\n    return {"id": item_id, "name": "Item Name"}\n```\n\n#### Built-in Error Handling\nFastAPI comes with built-in support for error handling, automatically generating error responses for certain types of exceptions, such as `HTTPException`.\n\n```python\n# Example of built-in error handling\nfrom fastapi import FastAPI, HTTPException\n\napp = FastAPI()\n\n@app.get("/items/{item_id}")\ndef read_item(item_id: int):\n    if item_id < 0:\n        raise HTTPException(status_code=400, detail="Item ID must be positive")\n    return {"id": item_id, "name": "Item Name"}\n```\n\n### Practical Exercise\nCreate a FastAPI application with an endpoint `/divide/{a}/{b}` that takes two integers `a` and `b` as path parameters and returns their division result. Implement error handling to catch and respond to the following scenarios:\n1. If `b` is zero, raise a `ZeroDivisionError`.\n2. If either `a` or `b` cannot be converted to an integer, raise a `ValueError`.\n\n```python\nfrom fastapi import FastAPI, HTTPException\nfrom fastapi.responses import JSONResponse\n\napp = FastAPI()\n\n@app.get("/divide/{a}/{b}")\ndef divide(a: str, b: str):\n    try:\n        a = int(a)\n        b = int(b)\n        if b == 0:\n            raise ZeroDivisionError("Cannot divide by zero")\n        result = a / b\n        return {"result": result}\n    except ValueError:\n        raise HTTPException(status_code=400, detail="Both \'a\' and \'b\' must be integers")\n    except ZeroDivisionError as e:\n        raise HTTPException(status_code=400, detail=str(e))\n```\n\nThis exercise helps reinforce the concepts of error handling in FastAPI, including the use of try-except blocks, custom exception handling, and built-in error handling features. By applying these concepts, developers can create more robust and user-friendly applications.',
    },
    {
      subtopic: 'Implementing CRUD Operations with FastAPI',
      content:
        '## Implementing CRUD Operations with FastAPI\n### Introduction\nImplementing CRUD (Create, Read, Update, Delete) operations is fundamental in building robust and interactive web applications. FastAPI, with its high-performance capabilities and strong support for asynchronous programming, makes implementing these operations straightforward and efficient. This section focuses on how to implement CRUD operations using FastAPI.\n\n### Detailed Explanation\nCRUD operations are the backbone of any database-driven application, allowing users to create new data, read existing data, update data, and delete data. FastAPI supports these operations through its routing system, where each operation is associated with a specific HTTP method: POST for create, GET for read, PUT or PATCH for update, and DELETE for delete.\n\n#### Creating Data (POST Request)\nTo create new data, you\'ll define a route that accepts POST requests. This route will typically expect JSON data in the request body, which will be used to create a new entry in your database.\n\n```python\n# Using Python with FastAPI\nfrom fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass Item(BaseModel):\n    id: int\n    name: str\n    description: str\n\n# Sample in-memory data store (in a real application, you\'d use a database)\nitems = []\n\n@app.post("/items/")\ndef create_item(item: Item):\n    items.append(item)\n    return item\n```\n\n#### Reading Data (GET Request)\nReading data involves fetching existing data from your database. This can be implemented using GET requests. You can fetch all items or a specific item by its ID.\n\n```python\n@app.get("/items/")\ndef read_all_items():\n    return items\n\n@app.get("/items/{item_id}")\ndef read_item(item_id: int):\n    for item in items:\n        if item.id == item_id:\n            return item\n    raise HTTPException(status_code=404, detail="Item not found")\n```\n\n#### Updating Data (PUT or PATCH Request)\nUpdating data allows users to modify existing entries in the database. This is typically done using PUT or PATCH requests. PUT is used for full updates (replacing the entire resource), while PATCH is used for partial updates.\n\n```python\n@app.put("/items/{item_id}")\ndef update_item(item_id: int, item: Item):\n    for i, existing_item in enumerate(items):\n        if existing_item.id == item_id:\n            items[i] = item\n            return item\n    raise HTTPException(status_code=404, detail="Item not found")\n\n@app.patch("/items/{item_id}")\ndef partial_update_item(item_id: int, item: Item):\n    for i, existing_item in enumerate(items):\n        if existing_item.id == item_id:\n            updated_item = existing_item.dict()\n            updated_item.update(item.dict(exclude_unset=True))\n            items[i] = Item(**updated_item)\n            return items[i]\n    raise HTTPException(status_code=404, detail="Item not found")\n```\n\n#### Deleting Data (DELETE Request)\nFinally, deleting data allows users to remove entries from the database. This is done using DELETE requests.\n\n```python\n@app.delete("/items/{item_id}")\ndef delete_item(item_id: int):\n    for i, item in enumerate(items):\n        if item.id == item_id:\n            del items[i]\n            return {"message": f"Item {item_id} deleted"}\n    raise HTTPException(status_code=404, detail="Item not found")\n```\n\n### Practical Exercise\nCreate a simple FastAPI application that manages books. Each book should have an ID, title, and author. Implement CRUD operations for books.\n\n1. Define a `Book` model using Pydantic.\n2. Create routes for creating, reading, updating, and deleting books.\n3. Test your application using tools like `curl` or a REST client (e.g., Postman).\n\n### Example Use Case\nTo test the `create_item` endpoint, you can use a tool like `curl` from the command line:\n\n```bash\ncurl -X \'POST\' \\\n  \'http://localhost:8000/items/\' \\\n  -H \'accept: application/json\' \\\n  -H \'Content-Type: application/json\' \\\n  -d \'{\n  "id": 1,\n  "name": "Sample Item",\n  "description": "This is a sample item"\n}\'\n```\n\nThis should return the created item, confirming that the CRUD operation was successful.',
    },
    {
      subtopic: 'Securing FastAPI Endpoints with Authentication',
      content:
        '### Securing FastAPI Endpoints with Authentication\n#### Introduction:\nSecuring FastAPI endpoints with authentication is crucial for protecting sensitive data and ensuring that only authorized users can access specific routes. This subtopic will delve into the methods and best practices for implementing authentication in FastAPI applications. Authentication in FastAPI can be achieved through various methods, including token-based authentication and OAuth.\n\n#### Detailed Explanation:\nFastAPI provides several ways to secure endpoints, but one of the most common and effective methods is by using authentication. Authentication can be implemented using libraries such as `fastapi.security` which provides support for OAuth2 and other authentication schemes. \n\nTo secure endpoints with authentication, you first need to define your authentication scheme. FastAPI supports several schemes out of the box, including:\n- **OAuth2**: A widely-used authorization framework that provides a secure way to access protected resources.\n- **Bearer Tokens**: A simple authentication scheme where clients include a token in the `Authorization` header of their requests.\n\nHere is an example of how you might define an OAuth2 scheme in FastAPI:\n```python\nfrom fastapi import FastAPI, Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\n\napp = FastAPI()\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")\n```\n\nAfter defining your authentication scheme, you can protect your endpoints by including a dependency on the authentication scheme:\n```python\nfrom fastapi import FastAPI, Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\n\napp = FastAPI()\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")\n\n@app.get("/items/")\nasync def read_items(token: str = Depends(oauth2_scheme)):\n    return {"token": token}\n```\n\nIn this example, the `/items/` endpoint will only be accessible if the client includes a valid token in the `Authorization` header of their request.\n\nAnother essential aspect of authentication in FastAPI is token validation. After obtaining a token, you must verify its validity on each subsequent request. FastAPI does not provide built-in token validation, but you can use external libraries such as `python-jose` to validate JWT tokens:\n```python\nimport jwt\n\nasync def validate_token(token: str):\n    try:\n        payload = jwt.decode(token, "secret_key", algorithms=["HS256"])\n        return payload\n    except jwt.ExpiredSignatureError:\n        raise HTTPException(status_code=401, detail="Token has expired")\n    except jwt.InvalidTokenError:\n        raise HTTPException(status_code=401, detail="Invalid token")\n```\n\n#### Practical Exercise:\nDesign a simple FastAPI application with authentication. The application should have two endpoints: one for obtaining a token and another for accessing protected data. The protected endpoint should only be accessible if the client includes a valid token in the `Authorization` header of their request.\n\nTo implement this exercise, follow these steps:\n1. Create a new FastAPI application.\n2. Define an OAuth2 scheme with a token URL.\n3. Create an endpoint for obtaining a token.\n4. Create a protected endpoint that depends on the OAuth2 scheme.\n5. Test the application by obtaining a token and using it to access the protected endpoint.\n\nExample code to get you started:\n```python\n# language: python\nfrom fastapi import FastAPI, Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\n\napp = FastAPI()\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")\n\n# Endpoint for obtaining a token\n@app.post("/token")\nasync def login(form_data: OAuth2PasswordRequestForm = Depends()):\n    # Validate the user\'s credentials and return a token\n    if form_data.username == "test" and form_data.password == "test":\n        return {"access_token": "example_token", "token_type": "bearer"}\n    else:\n        raise HTTPException(status_code=401, detail="Invalid credentials")\n\n# Protected endpoint\n@app.get("/protected/")\nasync def protected(token: str = Depends(oauth2_scheme)):\n    # Validate the token and return protected data\n    return {"message": "Hello, authenticated user!"}\n```\nThis example provides a basic authentication system where clients can obtain a token by sending a POST request to the `/token` endpoint with their username and password. The token can then be used to access the protected endpoint by including it in the `Authorization` header of the request.',
    },
    {
      subtopic: 'Deploying a FastAPI Application',
      content:
        '# Deploying a FastAPI Application\n## Introduction\nDeploying a FastAPI application is a crucial step in making your backend service available to users. This process involves setting up a production-ready environment, choosing a deployment strategy, and configuring your application for scalability and reliability. In this section, we will explore the key considerations and steps for deploying a FastAPI application.\n\n## Main Content\nDeploying a FastAPI application can be accomplished through various methods, including containerization using Docker, serverless deployment with AWS Lambda, and traditional deployment on a virtual private server (VPS) or a platform-as-a-service (PaaS) provider. Each approach has its advantages and challenges, and the choice of deployment strategy depends on the specific needs of your application, such as scalability requirements, performance expectations, and operational complexity.\n\n### Containerization with Docker\nDocker is a popular choice for deploying FastAPI applications due to its ease of use, flexibility, and efficiency. By containerizing your application, you can ensure consistent behavior across different environments, from development to production. Here is a basic example of how to create a Dockerfile for a FastAPI application:\n```python\n# Use an official Python runtime as a parent image\nFROM python:3.9-slim\n\n# Set the working directory in the container\nWORKDIR /app\n\n# Copy the requirements file\nCOPY requirements.txt .\n\n# Install any needed packages specified in requirements.txt\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Copy the application code\nCOPY . .\n\n# Make port 80 available to the world outside this container\nEXPOSE 80\n\n# Define environment variable\nENV NAME World\n\n# Run app.py when the container launches\nCMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "80"]\n```\nTo build and run your Docker image, you can use the following commands:\n```bash\ndocker build -t myfastapiapp .\ndocker run -d --name myfastapiapp -p 80:80 myfastapiapp\n```\n### Serverless Deployment with AWS Lambda\nServerless computing allows you to run your application without provisioning or managing servers. AWS Lambda is a fully managed service that can be used to deploy FastAPI applications. To deploy your FastAPI app to AWS Lambda, you will need to create a Lambda function, add an API Gateway trigger, and configure your function to handle incoming requests.\n\n### Traditional Deployment\nTraditional deployment involves running your FastAPI application directly on a server or a PaaS provider. This approach requires more manual configuration and maintenance compared to containerization or serverless deployment but can offer more control over the underlying infrastructure.\n\n## Exercise\nCreate a simple FastAPI application and deploy it using Docker. Follow these steps:\n1. Create a new directory for your project and navigate into it.\n2. Initialize a new FastAPI project using your preferred method (e.g., `fastapi` and `uvicorn` using pip).\n3. Create a `main.py` file and add a simple FastAPI endpoint.\n4. Create a `Dockerfile` in the root of your project directory.\n5. Build your Docker image and run it.\n6. Test your deployed application by visiting `http://localhost:80` in your web browser.\n\nExample `main.py`:\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get("/")\ndef read_root():\n    return {"Hello": "World"}\n```\nThis exercise will help you understand the basics of deploying a FastAPI application using Docker and prepare you for more complex deployment scenarios.',
    },
  ]);
}
