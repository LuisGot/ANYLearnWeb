import { computed, Injectable, signal } from '@angular/core';

@Injectable({
  providedIn: 'root',
})
export class CourseService {
  isLoading = signal(false);
  course = signal<{ subtopic: string; content: string }[]>([
    {
      subtopic: 'Introduction to FastAPI',
      content:
        '# Introduction to FastAPI\n## Overview\nFastAPI is a modern, fast (high-performance), web framework for building APIs with Python 3.7+ based on standard Python type hints. It is designed to be fast, robust, and easy to use, making it an excellent choice for building high-performance APIs.\n\n## Main Content\n### What is FastAPI?\nFastAPI is an asynchronous framework, which means it can handle multiple requests at the same time, making it very efficient. It also includes automatic interactive API documentation, which can be accessed directly from the web interface. This feature allows developers to easily test and document their APIs.\n\n### Features of FastAPI\nSome of the key features of FastAPI include:\n* **High performance**: FastAPI is designed to be fast and can handle a high volume of requests.\n* **Automatic API documentation**: FastAPI automatically generates API documentation, making it easy to test and document APIs.\n* **Strongly typed**: FastAPI uses Python type hints to define the structure of the data, which helps catch errors at runtime.\n* **Robust error handling**: FastAPI has built-in support for error handling, making it easy to handle and return errors to the client.\n\n### Why Use FastAPI?\nFastAPI is a great choice for building APIs because it is fast, easy to use, and has a lot of built-in features that make it easy to build robust and scalable APIs. Additionally, FastAPI has a strong focus on developer experience, with features like automatic API documentation and interactive testing.\n\n### Example Use Case\nHere is an example of a simple "Hello, World!" API using FastAPI:\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get("/")\ndef read_root():\n    return {"Hello": "World"}\n```\nThis example shows how easy it is to create a simple API using FastAPI.\n\n## Exercise\nCreate a new FastAPI project and run it. Then, use a tool like `curl` or a web browser to test the API. Try modifying the API to return a different message.\n\n### Step-by-Step Instructions\n1. Install FastAPI using pip: `pip install fastapi`\n2. Create a new file called `main.py` and add the following code:\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get("/")\ndef read_root():\n    return {"Hello": "World"}\n```\n3. Run the API using `uvicorn`: `uvicorn main:app --host 0.0.0.0 --port 8000`\n4. Use `curl` or a web browser to test the API: `curl http://localhost:8000/`\n5. Modify the API to return a different message and test it again.\n\nBy following these steps, you can create and test a simple FastAPI API. This exercise demonstrates how easy it is to get started with FastAPI and how it can be used to build robust and scalable APIs.',
    },
    {
      subtopic: 'Setting Up a FastAPI Project',
      content:
        '# Setting Up a FastAPI Project\n## Introduction\nSetting up a FastAPI project is the foundational step in creating robust, scalable, and maintainable web applications. FastAPI, a modern, fast (high-performance), web framework for building APIs with Python 3.7+ based on standard Python type hints, offers a structured way to build projects efficiently. This section guides you through the initial setup, ensuring you\'re well-prepared to dive into more advanced topics.\n\n## Detailed Explanation\n### Prerequisites\nBefore setting up a FastAPI project, you\'ll need Python 3.7 or higher installed on your system. It\'s also recommended to use a virtual environment for project dependencies to keep them isolated from the system Python installation.\n\n### Step 1: Installing FastAPI and uvicorn\nTo start a new FastAPI project, you\'ll first need to install FastAPI itself along with an ASGI server. `uvicorn` is a popular choice for serving FastAPI applications. You can install them using pip:\n```python\n# Install FastAPI and uvicorn\npip install fastapi uvicorn\n```\n\n### Step 2: Creating the Project Structure\nA basic FastAPI project can be as simple as a single file, but for larger applications, organizing your code into logical modules and directories is essential. Create a directory for your project and navigate into it:\n```bash\n# Create a directory for your project and navigate into it\nmkdir myfastapiapp\ncd myfastapiapp\n```\nThen, you can create a basic structure for your application. For a small project, you might start with a single file named `main.py`.\n\n### Step 3: Writing Your First FastAPI App\nIn `main.py`, you can create your first FastAPI application:\n```python\n# main.py\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get("/")\ndef read_root():\n    return {"Hello": "World"}\n```\nThis code snippet creates a FastAPI app with a single endpoint, `/`, which returns a JSON response.\n\n### Step 4: Running Your FastAPI Application\nWith your application defined, you can run it using `uvicorn`. Execute the following command in your terminal:\n```bash\n# Run the application\nuvicorn main:app --reload\n```\nThe `--reload` flag tells `uvicorn` to reload the application if it detects any changes to the source code, which is very useful during development.\n\n## Practical Exercise\n### Exercise: Creating a Personalized Hello World Endpoint\n1. **Modify the Existing Endpoint:** Update the `/` endpoint in your `main.py` file to accept a query parameter `name`. Use this parameter to return a personalized greeting.\n2. **Add a New Endpoint:** Create a new endpoint, `/hello/{name}`, that uses a path parameter to provide the same functionality as the modified `/` endpoint.\n3. **Run Your Application:** Restart your FastAPI application to apply the changes.\n4. **Test Your Endpoints:** Use a tool like `curl` or a web browser to test both endpoints. For example, you can use the following `curl` commands:\n    ```bash\n    # Test the / endpoint with a query parameter\n    curl http://127.0.0.1:8000/?name=Alice\n    \n    # Test the /hello/{name} endpoint\n    curl http://127.0.0.1:8000/hello/Bob\n    ```\n5. **Verify the Responses:** Ensure both endpoints return the expected personalized greetings.\n\nBy completing this exercise, you\'ll have hands-on experience with setting up a FastAPI project, defining endpoints, and handling different types of parameters. This foundational knowledge will be crucial as you progress to more complex topics in FastAPI development.',
    },
    {
      subtopic: 'Understanding FastAPI Routing',
      content:
        '# Understanding FastAPI Routing\n## Introduction\nFastAPI routing is a crucial aspect of building robust and scalable web applications. It allows developers to map specific URLs to application endpoints, making it easier to manage and maintain complex applications. Understanding FastAPI routing is essential for creating efficient and organized API structures.\n\n## Detailed Explanation\nFastAPI routing is based on the concept of routes, which are essentially mappings between URLs and application endpoints. Routes can be defined using the `@app` decorator, where `app` is an instance of the FastAPI application. Each route is associated with a specific HTTP method, such as GET, POST, PUT, or DELETE, and can include path parameters, query parameters, and request bodies.\n\n### Key Concepts and Definitions\n* **Route**: A mapping between a URL and an application endpoint.\n* **Path Parameter**: A parameter that is part of the URL path.\n* **Query Parameter**: A parameter that is passed as a query string in the URL.\n* **Request Body**: The data sent in the request body, typically in JSON format.\n\n### Example Routing Configuration\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n# Define a route for the root URL\n@app.get("/")\ndef read_root():\n    return {"message": "Welcome to FastAPI"}\n\n# Define a route with a path parameter\n@app.get("/items/{item_id}")\ndef read_item(item_id: int):\n    return {"item_id": item_id}\n\n# Define a route with a query parameter\n@app.get("/items/")\ndef read_items(q: str = None):\n    if q:\n        return {"items": [{"item_id": 1, "name": "Item 1"}, {"item_id": 2, "name": "Item 2"}]}\n    else:\n        return {"items": []}\n```\nIn this example, we define three routes: one for the root URL, one with a path parameter, and one with a query parameter.\n\n## Practical Exercise\nCreate a new FastAPI application and define the following routes:\n* A route for the root URL (`"/"`) that returns a JSON response with a message.\n* A route with a path parameter (`"/items/{item_id}"`) that returns a JSON response with the item ID.\n* A route with a query parameter (`"/items/"`) that returns a JSON response with a list of items.\n\nUse the following code as a starting point:\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n# Define the routes here\n```\nWhen you run the application, use a tool like `curl` or a web browser to test the routes and verify that they return the expected responses.\n\n## Conclusion\nUnderstanding FastAPI routing is essential for building efficient and scalable web applications. By defining routes with path parameters, query parameters, and request bodies, developers can create complex API structures that are easy to manage and maintain. With practice and experience, developers can master FastAPI routing and build robust and scalable applications.',
    },
    {
      subtopic: 'Creating Simple Endpoints',
      content:
        '# Creating Simple Endpoints\n## Introduction\nCreating simple endpoints is a fundamental concept in FastAPI, allowing developers to define routes for handling HTTP requests and returning responses. This subtopic focuses on the basics of endpoint creation, providing a solid foundation for further exploration of FastAPI\'s capabilities. Understanding how to create simple endpoints is crucial for building robust and efficient APIs.\n\n## Detailed Explanation\nTo create a simple endpoint in FastAPI, you start by importing the FastAPI class and creating an instance of it. This instance represents your API application. Then, you use the `@app` decorator followed by the HTTP method you want to support (e.g., `@app.get()`, `@app.post()`, etc.) to define a route. The route is associated with a Python function that will handle the request and return a response.\n\n### Key Concepts\n- **Route**: A path in your API that maps to a specific function that handles HTTP requests.\n- **Endpoint**: The combination of a route and an HTTP method (like GET, POST, PUT, DELETE) that defines how to handle requests to that route.\n- **Request**: The data sent by the client to the server, which can include path parameters, query parameters, headers, and a body.\n- **Response**: The data sent back by the server to the client in response to a request.\n\n### Example\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n# Define a simple GET endpoint\n@app.get("/hello")\ndef read_root():\n    return {"message": "Hello, World!"}\n```\nIn this example, `"/hello"` is the route, and the `read_root` function handles GET requests to this route, returning a JSON response.\n\n## Practical Exercise\n### Task\nCreate a new FastAPI application with two simple endpoints: one for the root path (`"/"`) that returns a welcome message, and another (`"/items/"`) that returns a list of item names.\n\n### Steps\n1. Install FastAPI and uvicorn (a server to run your application) if you haven\'t already:\n```bash\npip install fastapi uvicorn\n```\n2. Create a new Python file, e.g., `main.py`, and define your FastAPI application there.\n3. Import FastAPI, create an instance of it, and define the two endpoints as described.\n4. Run your application with uvicorn:\n```bash\nuvicorn main:app --reload\n```\n5. Use a tool like `curl` or a web browser to test your endpoints.\n\n### Solution\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n# Endpoint for the root path\n@app.get("/")\ndef read_root():\n    return {"message": "Welcome to my API!"}\n\n# Endpoint for items\n@app.get("/items/")\ndef read_items():\n    item_list = ["Item1", "Item2", "Item3"]\n    return {"items": item_list}\n```\nThis exercise demonstrates how to create simple endpoints in FastAPI, returning JSON responses to HTTP GET requests. It\'s a foundational skill for building more complex and interactive APIs with FastAPI.',
    },
    {
      subtopic: 'Working with Path Parameters',
      content:
        '# Working with Path Parameters\n## Introduction\nWorking with path parameters is a crucial aspect of building robust and flexible APIs using FastAPI. Path parameters allow you to capture values from the URL path and use them within your API endpoints, making it possible to create dynamic and data-driven APIs. This section will delve into the details of how to work with path parameters in FastAPI, including how to define them, access their values, and use them in your API endpoints.\n\n## Detailed Explanation\nPath parameters in FastAPI are defined using curly braces `{}` within the path of an endpoint. For example, if you want to create an endpoint that captures a user ID from the URL path, you can define it as follows:\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get("/users/{user_id}")\nasync def read_user(user_id: int):\n    return {"user_id": user_id}\n```\nIn this example, `user_id` is a path parameter that is captured from the URL path and passed to the `read_user` function as an argument. The `int` type hint indicates that the `user_id` path parameter should be an integer.\n\nYou can also use multiple path parameters in a single endpoint by separating them with slashes `/`. For example:\n```python\n@app.get("/users/{user_id}/items/{item_id}")\nasync def read_item(user_id: int, item_id: int):\n    return {"user_id": user_id, "item_id": item_id}\n```\nIn this example, `user_id` and `item_id` are both path parameters that are captured from the URL path and passed to the `read_item` function as arguments.\n\n## Path Parameter Validation\nFastAPI provides built-in support for validating path parameters using type hints. For example, you can use the `str` type hint to indicate that a path parameter should be a string:\n```python\n@app.get("/users/{username}")\nasync def read_user(username: str):\n    return {"username": username}\n```\nYou can also use more advanced validation techniques, such as using Pydantic models to define the structure of the path parameters. For example:\n```python\nfrom pydantic import BaseModel\n\nclass User(BaseModel):\n    id: int\n    name: str\n\n@app.get("/users/{user_id}")\nasync def read_user(user_id: int):\n    user = User(id=user_id, name="John Doe")\n    return user\n```\nIn this example, the `User` model defines the structure of the `user_id` path parameter, and the `read_user` function uses this model to validate and parse the path parameter.\n\n## Path Parameter Defaults\nYou can also define default values for path parameters using the `Default` class from the `fastapi` module. For example:\n```python\nfrom fastapi import FastAPI, Path\n\napp = FastAPI()\n\n@app.get("/users/{user_id}")\nasync def read_user(user_id: int = Path(..., default=1)):\n    return {"user_id": user_id}\n```\nIn this example, the `user_id` path parameter has a default value of `1`, which is used if no value is provided in the URL path.\n\n## Practical Exercise\nCreate a new FastAPI application and define an endpoint that captures a user ID from the URL path using a path parameter. Use the `int` type hint to validate the path parameter and return a JSON response with the user ID.\n\n```python\n# Define a new FastAPI application\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n# Define an endpoint that captures a user ID from the URL path\n@app.get("/users/{user_id}")\nasync def read_user(user_id: int):\n    # Return a JSON response with the user ID\n    return {"user_id": user_id}\n\n# Run the application\nif __name__ == "__main__":\n    import uvicorn\n    uvicorn.run(app, host="0.0.0.0", port=8000)\n```\nRun the application and access the endpoint using a tool like `curl` to test the path parameter validation and JSON response:\n```bash\ncurl http://localhost:8000/users/1\n```\nThis should return a JSON response with the user ID:\n```json\n{\n  "user_id": 1\n}\n```',
    },
    {
      subtopic: 'Request and Response Objects',
      content:
        '# Request and Response Objects\n## Introduction\nRequest and Response objects are fundamental components in FastAPI, enabling the development of robust and interactive web applications. Understanding these objects is crucial for handling HTTP requests and generating appropriate responses. In this section, we will delve into the details of Request and Response objects, exploring their properties, methods, and usage.\n\n## Main Content\n### Request Object\nThe Request object in FastAPI represents an incoming HTTP request. It contains information about the request, such as the method (e.g., GET, POST, PUT, DELETE), URL, headers, and body. The Request object is an instance of the `Request` class from the `fastapi` module.\n\n#### Properties and Methods\nThe Request object has several properties and methods that provide access to the request data:\n\n* `method`: The HTTP method of the request (e.g., "GET", "POST").\n* `url`: The URL of the request.\n* `headers`: A dictionary-like object containing the request headers.\n* `body`: The body of the request as a bytes object.\n* `json()`: A method that parses the request body as JSON and returns a dictionary.\n* `form()`: A method that parses the request body as form data and returns a dictionary.\n\n### Response Object\nThe Response object in FastAPI represents an outgoing HTTP response. It contains information about the response, such as the status code, headers, and body. The Response object is an instance of the `Response` class from the `fastapi` module.\n\n#### Properties and Methods\nThe Response object has several properties and methods that allow customization of the response:\n\n* `status_code`: The HTTP status code of the response (e.g., 200, 404, 500).\n* `headers`: A dictionary-like object containing the response headers.\n* `body`: The body of the response as a bytes object.\n* `media_type`: The media type of the response (e.g., "application/json").\n* `set_cookie()`: A method that sets a cookie in the response.\n\n### Example Usage\n```python\nfrom fastapi import FastAPI, Request, Response\n\napp = FastAPI()\n\n@app.get("/items/")\nasync def read_items(request: Request):\n    # Accessing the request method and URL\n    print(request.method)\n    print(request.url)\n\n    # Returning a response with a custom status code and header\n    return Response(status_code=201, headers={"X-Custom-Header": "Hello World"})\n\n@app.post("/items/")\nasync def create_item(request: Request):\n    # Parsing the request body as JSON\n    data = await request.json()\n    print(data)\n\n    # Returning a response with a JSON body\n    return {"message": "Item created successfully"}\n```\nIn this example, we define two endpoints: one for reading items and another for creating items. The `read_items` function demonstrates how to access the request method and URL, as well as return a custom response with a specific status code and header. The `create_item` function shows how to parse the request body as JSON and return a response with a JSON body.\n\n## Exercise\nCreate a new FastAPI application that includes two endpoints: one for reading a user\'s profile and another for updating a user\'s profile. The `read_profile` endpoint should accept a `user_id` path parameter and return a JSON response with the user\'s profile data. The `update_profile` endpoint should accept a `user_id` path parameter and a JSON body with the updated profile data, and return a JSON response with a success message.\n\n```python\n# Solution\nfrom fastapi import FastAPI, Request, Response\n\napp = FastAPI()\n\n# Sample user data\nusers = {\n    1: {"name": "John Doe", "email": "johndoe@example.com"},\n    2: {"name": "Jane Doe", "email": "janedoe@example.com"}\n}\n\n@app.get("/users/{user_id}")\nasync def read_profile(user_id: int, request: Request):\n    # Return the user\'s profile data as JSON\n    return users.get(user_id, {})\n\n@app.put("/users/{user_id}")\nasync def update_profile(user_id: int, request: Request):\n    # Parse the request body as JSON\n    data = await request.json()\n    \n    # Update the user\'s profile data\n    users[user_id] = data\n    \n    # Return a JSON response with a success message\n    return {"message": "Profile updated successfully"}\n```',
    },
    {
      subtopic: 'Handling JSON Data with Pydantic',
      content:
        '# Handling JSON Data with Pydantic\n## Introduction\nHandling JSON data is a crucial aspect of building robust and efficient web applications, and when combined with Pydantic, FastAPI developers can leverage the power of automatic data validation, parsing, and serialization. Pydantic is a runtime type checker and validator that works seamlessly with FastAPI to simplify the process of working with JSON data.\n\n## Understanding Pydantic and Its Role in FastAPI\nPydantic plays a vital role in FastAPI by providing the framework with the ability to automatically validate and parse JSON data sent in requests and to serialize Python objects into JSON responses. This integration not only streamlines the development process but also significantly improves the reliability and performance of the application by ensuring that data conforms to expected structures and formats.\n\n### Key Features of Pydantic\n- **Validation**: Pydantic models automatically validate the data they are instantiated with, ensuring that it matches the predefined structure.\n- **Serialization**: Pydantic models can be easily converted into JSON, making them ideal for generating API responses.\n- **Error Handling**: Pydantic provides detailed error messages when validation fails, which can be directly returned to clients to inform them about the issues with their requests.\n\n## Creating Pydantic Models\nTo handle JSON data with Pydantic in a FastAPI application, you start by defining models. These models represent the structure of the JSON data you expect to receive or send.\n\n```python\nfrom pydantic import BaseModel\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: str\n```\n\n## Using Pydantic Models in FastAPI Endpoints\nOnce you have defined your Pydantic models, you can use them to define the structure of request bodies in your FastAPI endpoints. FastAPI will automatically validate the incoming request data against the model and return a 422 Unprocessable Entity response if the data is invalid.\n\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: str\n\n@app.post("/users/")\ndef create_user(user: User):\n    return user\n```\n\n## Practical Exercise\nDesign a simple FastAPI endpoint that accepts a JSON object representing a book, with fields for `title`, `author`, and `publication_year`. The endpoint should validate the incoming JSON data using a Pydantic model and return the validated data as a response.\n\n### Step 1: Define the Pydantic Model\nFirst, define a Pydantic model for the book:\n\n```python\nfrom pydantic import BaseModel\n\nclass Book(BaseModel):\n    title: str\n    author: str\n    publication_year: int\n```\n\n### Step 2: Create the FastAPI Endpoint\nNext, create the FastAPI endpoint that uses the `Book` model for validation:\n\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass Book(BaseModel):\n    title: str\n    author: str\n    publication_year: int\n\n@app.post("/books/")\ndef create_book(book: Book):\n    return book\n```\n\n### Step 3: Test the Endpoint\nTest the endpoint by sending a POST request with a JSON body that matches the `Book` model. You can use tools like curl or Postman for this.\n\n```bash\ncurl -X \'POST\' \\\n  \'http://localhost:8000/books/\' \\\n  -H \'accept: application/json\' \\\n  -H \'Content-Type: application/json\' \\\n  -d \'{\n  "title": "Example Book",\n  "author": "John Doe",\n  "publication_year": 2022\n}\'\n```\n\nThis exercise demonstrates how to use Pydantic with FastAPI to handle JSON data efficiently, ensuring that your application is robust, scalable, and easy to maintain.',
    },
    {
      subtopic: 'Defining Response Models',
      content:
        '# Defining Response Models\n## Introduction\nDefining response models is a crucial step in building robust and well-structured APIs with FastAPI. It allows developers to define the structure of the data returned by their API endpoints, ensuring consistency and clarity for consumers. By using response models, developers can take advantage of FastAPI\'s automatic API documentation and validation features.\n\n## Main Content\nResponse models in FastAPI are typically defined using Pydantic models. Pydantic is a Python library for building robust, scalable, and fast data validation and parsing. It integrates seamlessly with FastAPI, enabling developers to define their API\'s data models in a straightforward and Pythonic way.\n\n### Key Concepts\n- **Pydantic Models**: These are classes that define the structure of data. They can include fields of various types, such as integers, strings, and even nested models.\n- **Validation**: Pydantic models automatically validate data against their definitions, ensuring that the data conforms to the expected structure. This validation happens both for incoming request data and outgoing response data.\n- **Response Model Definition**: In the context of FastAPI, response models are used to define the expected structure of the data returned by an API endpoint.\n\n### Example\nHere\'s an example of how you might define a simple response model for a user endpoint:\n```python\nfrom pydantic import BaseModel\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: str\n\n@app.get("/users/{user_id}", response_model=User)\nasync def read_user(user_id: int):\n    # This is a placeholder for actual database or external data access\n    # For demonstration purposes, we\'re returning static data\n    return User(id=user_id, name="John Doe", email="john@example.com")\n```\nIn this example, `User` is a Pydantic model that defines a user\'s structure with an `id`, `name`, and `email`. The `read_user` endpoint uses this model as its `response_model`, ensuring that FastAPI will validate and document the response structure based on the `User` model.\n\n## Exercise\n1. **Define Your Own Response Model**: Create a Pydantic model for a `Book` with fields for `title`, `author`, and `publication_year`.\n2. **Implement an Endpoint**: Use FastAPI to create an endpoint `/books/{book_id}` that returns a `Book` object based on the provided `book_id`. Ensure that the endpoint uses the `Book` model as its response model.\n3. **Test Your Endpoint**: Use a tool like `curl` or an API client (e.g., Postman) to test your endpoint and verify that it returns the expected data structure.\n\n### Example Solution\n```python\nfrom pydantic import BaseModel\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\nclass Book(BaseModel):\n    title: str\n    author: str\n    publication_year: int\n\n@app.get("/books/{book_id}", response_model=Book)\nasync def read_book(book_id: int):\n    # Placeholder data for demonstration\n    return Book(title="Example Book", author="Example Author", publication_year=2020)\n```\nBy following these steps and experimenting with different models and endpoints, you can become proficient in defining response models for your FastAPI applications, enhancing their clarity, consistency, and usability.',
    },
    {
      subtopic: 'Building Endpoints with JSON Response',
      content:
        '# Building Endpoints with JSON Response\n## Introduction\nBuilding endpoints with JSON response is a critical aspect of developing RESTful APIs with FastAPI. JSON (JavaScript Object Notation) is a lightweight data interchange format that is easy to read and write, making it a popular choice for exchanging data between web servers and web applications. In this section, we will explore how to create endpoints that return JSON responses using FastAPI.\n\n## Understanding JSON Response\nWhen building endpoints with JSON response, it\'s essential to understand how FastAPI handles JSON data. FastAPI uses the Pydantic library to validate and serialize data, making it easy to work with JSON data. Pydantic provides a simple and intuitive way to define data models, which can be used to generate JSON schemas and validate JSON data.\n\n## Creating Endpoints with JSON Response\nTo create an endpoint that returns a JSON response, you need to define a route function that returns a JSON-serializable object. FastAPI provides several ways to return JSON responses, including using the `JSONResponse` object, the `dict` type, or Pydantic models.\n\n### Example: Returning a Simple JSON Response\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get("/items/")\ndef read_items():\n    return [{"item_id": 1, "item_name": "Item 1"}, {"item_id": 2, "item_name": "Item 2"}]\n```\nIn this example, the `read_items` function returns a list of dictionaries, which is converted to a JSON response by FastAPI.\n\n### Example: Using Pydantic Models to Return JSON Response\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass Item(BaseModel):\n    item_id: int\n    item_name: str\n\n@app.get("/items/")\ndef read_items():\n    return [Item(item_id=1, item_name="Item 1"), Item(item_id=2, item_name="Item 2")]\n```\nIn this example, we define a Pydantic model `Item` that represents an item with an `item_id` and an `item_name`. We then use this model to return a list of items, which is converted to a JSON response by FastAPI.\n\n## Exercise: Building Endpoints with JSON Response\nCreate a new FastAPI application and define a route `/users/` that returns a list of users in JSON format. Each user should have an `id`, a `name`, and an `email`. Use Pydantic models to define the user data structure.\n\n```python\n# Solution\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: str\n\n@app.get("/users/")\ndef read_users():\n    return [User(id=1, name="John Doe", email="john@example.com"), User(id=2, name="Jane Doe", email="jane@example.com")]\n```\nRun the application and access the `/users/` endpoint to see the JSON response.',
    },
    {
      subtopic: 'Error Handling in FastAPI',
      content:
        '# Error Handling in FastAPI\n## Introduction\nError handling is a crucial aspect of building robust and reliable applications with FastAPI. It allows developers to gracefully manage unexpected situations, providing useful feedback to users and ensuring the application remains stable. This section delves into the principles and practices of error handling in FastAPI, equipping developers with the tools to handle errors effectively.\n\n## Understanding Error Handling in FastAPI\nFastAPI provides a structured approach to error handling, leveraging Python\'s exception handling mechanisms along with its own features for custom error handling. Errors in FastAPI can be broadly categorized into two types: standard HTTP errors and custom application errors. Standard HTTP errors cover scenarios like 404 Not Found, 500 Internal Server Error, etc., while custom application errors are specific to the application\'s logic and requirements.\n\n### Key Concepts and Definitions\n- **HTTP Errors**: These are standard errors defined by the HTTP protocol, such as 404 for Not Found, 401 for Unauthorized, etc.\n- **Custom Errors**: Application-specific errors that don\'t fit into standard HTTP error categories.\n- **Exception Handling**: The process of catching and managing errors (exceptions) at runtime.\n\n### Handling HTTP Errors\nFastAPI automatically handles standard HTTP errors. For example, if a requested path does not exist, FastAPI will return a 404 error. However, you can also manually raise HTTP errors using the `HTTPException` class from FastAPI.\n\n```python\nfrom fastapi import FastAPI, HTTPException\n\napp = FastAPI()\n\n@app.get("/items/{item_id}")\nasync def read_item(item_id: int):\n    if item_id < 0:\n        raise HTTPException(status_code=404, detail="Item not found")\n    # Item retrieval logic here\n    return {"item_id": item_id}\n```\n\n### Creating Custom Error Handling\nFor application-specific errors, you can create custom exceptions and handle them accordingly. This involves defining your exception class and then using it to raise exceptions.\n\n```python\nfrom fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\nclass InvalidItemError(Exception):\n    def __init__(self, name: str):\n        self.name = name\n        super().__init__(name)\n\n@app.exception_handler(InvalidItemError)\nasync def invalid_item_error_handler(request: Request, exc: InvalidItemError):\n    return JSONResponse(status_code=400, content={"message": f"Invalid item: {exc.name}"})\n\n@app.get("/items/{item_name}")\nasync def read_item(item_name: str):\n    if item_name == "foo":\n        raise InvalidItemError(name=item_name)\n    # Item retrieval logic here\n    return {"item_name": item_name}\n```\n\n### Practical Exercise\nCreate a FastAPI application that includes the following:\n1. An endpoint `/users/{user_id}` to retrieve a user by ID.\n2. Raise a 404 error if the user ID is less than 1.\n3. Define a custom exception `UserNotFoundError` and raise it if the user ID is exactly 0.\n4. Implement an exception handler for `UserNotFoundError` to return a JSON response with a custom error message.\n\n```python\nfrom fastapi import FastAPI, HTTPException\nfrom fastapi.responses import JSONResponse\n\napp = FastAPI()\n\nclass UserNotFoundError(Exception):\n    pass\n\n@app.exception_handler(UserNotFoundError)\nasync def user_not_found_error_handler(request: Request, exc: UserNotFoundError):\n    return JSONResponse(status_code=404, content={"message": "User not found"})\n\n@app.get("/users/{user_id}")\nasync def read_user(user_id: int):\n    if user_id == 0:\n        raise UserNotFoundError()\n    elif user_id < 1:\n        raise HTTPException(status_code=404, detail="User ID must be greater than 0")\n    # User retrieval logic here\n    return {"user_id": user_id}\n```\n\n## Conclusion\nEffective error handling is pivotal for developing reliable and user-friendly FastAPI applications. By understanding how to leverage FastAPI\'s built-in error handling features and create custom error handling mechanisms, developers can ensure their applications provide meaningful feedback and maintain stability even in unexpected scenarios.',
    },
    {
      subtopic: 'Validation and Serialization',
      content:
        '# Validation and Serialization\n## Introduction\nValidation and serialization are crucial components in building robust and scalable APIs with FastAPI. They ensure data integrity, security, and consistency by verifying the structure and type of data exchanged between the client and server.\n\n## Understanding Validation and Serialization\nValidation refers to the process of checking if the data sent by the client adheres to the expected format and constraints, such as data types, lengths, and patterns. Serialization, on the other hand, is the process of converting complex data types, such as Python objects, into a format that can be easily sent over the network, like JSON. In FastAPI, Pydantic models play a vital role in both validation and serialization.\n\n## Pydantic Models for Validation\nPydantic models provide a simple and powerful way to define the structure of the data. They automatically handle validation, converting the input data into the model\'s attributes, and provide informative error messages for any validation failures. Here\'s an example of a basic Pydantic model:\n```python\nfrom pydantic import BaseModel\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: str\n```\nThis model can be used in a FastAPI endpoint to validate incoming requests:\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: str\n\n@app.post("/users/")\nasync def create_user(user: User):\n    return user\n```\nIn this example, FastAPI will automatically validate the incoming JSON data against the `User` model. If the validation fails, it will return a 422 Unprocessable Entity response with details about the validation error.\n\n## Serialization with Pydantic\nPydantic models can also be used for serialization. When a model instance is returned from an endpoint, FastAPI will automatically convert it into a JSON response. This ensures that the data is sent in a consistent and predictable format:\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: str\n\n@app.get("/users/{user_id}")\nasync def read_user(user_id: int):\n    # Assuming we have a way to fetch a user by ID\n    user = User(id=user_id, name="John Doe", email="john.doe@example.com")\n    return user\n```\nIn this example, the `User` model instance is returned from the endpoint, and FastAPI will automatically serialize it into a JSON response.\n\n## Exercise: Creating and Validating a Pydantic Model\nCreate a Pydantic model for a blog post that includes the title, content, and author\'s name. Use the model in a FastAPI endpoint to validate incoming requests. Then, modify the endpoint to return a serialized version of the blog post model.\n\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass BlogPost(BaseModel):\n    title: str\n    content: str\n    author: str\n\n@app.post("/blog-posts/")\nasync def create_blog_post(blog_post: BlogPost):\n    # Save the blog post to the database or perform any other necessary actions\n    return blog_post\n```\nTest your endpoint by sending a POST request with a JSON body that matches the `BlogPost` model. Verify that the endpoint returns a 422 error response if the validation fails and a successful response with the serialized blog post data if the validation succeeds.',
    },
    {
      subtopic: 'API Documentation with Swagger UI',
      content:
        '# API Documentation with Swagger UI\n## Introduction\nAPI documentation is a crucial aspect of developing RESTful APIs, as it provides a clear understanding of the API\'s functionality, endpoints, and usage. Swagger UI is a popular tool for generating interactive API documentation. In this section, we will explore how to integrate Swagger UI with FastAPI to create comprehensive and user-friendly API documentation.\n\n## Main Content\nFastAPI provides built-in support for Swagger UI through the `swagger_ui` and `redoc` endpoints. When you run a FastAPI application, you can access the Swagger UI documentation by navigating to `http://localhost:8000/docs` in your web browser.\n\n### What is Swagger UI?\nSwagger UI is an open-source tool that allows users to visualize and interact with API endpoints. It provides a graphical interface for testing API requests, viewing responses, and exploring API documentation.\n\n### Configuring Swagger UI in FastAPI\nTo configure Swagger UI in FastAPI, you can use the `OpenAPI` class to define the API\'s metadata, such as the title, description, and version. You can also use the `@app.get("/docs")` decorator to define a custom endpoint for Swagger UI.\n\n```python\nfrom fastapi import FastAPI\nfrom fastapi.openapi.docs import get_swagger_ui_html\n\napp = FastAPI(\n    title="My API",\n    description="This is my API",\n    version="1.0.0"\n)\n\n@app.get("/docs")\ndef get_docs():\n    return get_swagger_ui_html(openapi_url="/openapi.json", title="My API")\n\n```\n\n### Customizing Swagger UI\nYou can customize the Swagger UI configuration by passing additional parameters to the `get_swagger_ui_html` function. For example, you can change the title, description, or add custom CSS styles.\n\n```python\nfrom fastapi import FastAPI\nfrom fastapi.openapi.docs import get_swagger_ui_html\n\napp = FastAPI(\n    title="My API",\n    description="This is my API",\n    version="1.0.0"\n)\n\n@app.get("/docs")\ndef get_docs():\n    return get_swagger_ui_html(\n        openapi_url="/openapi.json",\n        title="My Custom API",\n        swagger_css_url="https://example.com/custom.css"\n    )\n```\n\n## Exercise\nCreate a new FastAPI application with a single endpoint that returns a JSON response. Use Swagger UI to document the endpoint and test it using the interactive API documentation.\n\n```python\n# Language: python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass Item(BaseModel):\n    name: str\n    price: float\n\n@app.get("/items/")\ndef read_items():\n    return [{"name": "Item1", "price": 10.99}]\n```\n\nRun the application and navigate to `http://localhost:8000/docs` to access the Swagger UI documentation. Use the interactive interface to test the `/items/` endpoint and view the response.\n\nRemember to replace the `http://localhost:8000` URL with the actual URL of your FastAPI application.\n\nBy following these steps, you can create comprehensive and user-friendly API documentation for your FastAPI application using Swagger UI.',
    },
    {
      subtopic: 'Deploying a FastAPI Application',
      content:
        '# Deploying a FastAPI Application\nDeploying a FastAPI application involves making the application accessible to users over the internet. This can be achieved by hosting the application on a server or cloud platform. The deployment process typically involves several steps, including preparing the application for deployment, choosing a deployment method, and configuring the server or cloud platform.\n## Introduction to Deployment\nBefore deploying a FastAPI application, it\'s essential to understand the different deployment options available. Some popular deployment methods include containerization using Docker, serverless deployment using AWS Lambda, and traditional server deployment using a WSGI server like Gunicorn or Uvicorn.\n\n## Choosing a Deployment Method\nThe choice of deployment method depends on several factors, including the application\'s requirements, scalability needs, and maintenance costs. Here are some popular deployment methods:\n* **Containerization using Docker**: This method involves packaging the application and its dependencies into a Docker container, which can be run on any system that supports Docker.\n* **Serverless deployment using AWS Lambda**: This method involves deploying the application as a serverless function, which can be executed on demand without the need for a dedicated server.\n* **Traditional server deployment using a WSGI server**: This method involves deploying the application on a traditional server using a WSGI server like Gunicorn or Uvicorn.\n\n## Preparing the Application for Deployment\nBefore deploying the application, it\'s essential to prepare it for deployment by:\n* **Freezing dependencies**: Freezing dependencies involves specifying the exact versions of dependencies required by the application.\n* **Creating a Dockerfile**: A Dockerfile is a text file that contains instructions for building a Docker image.\n* **Configuring environment variables**: Environment variables need to be configured to ensure the application can connect to databases, APIs, and other external services.\n\n## Deploying the Application\nOnce the application is prepared for deployment, it can be deployed using the chosen deployment method. Here is an example of how to deploy a FastAPI application using Docker:\n```python\n# Import the required libraries\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\n\n# Create a FastAPI application\napp = FastAPI()\n\n# Define a simple endpoint\n@app.get("/")\ndef read_root():\n    return {"message": "Welcome to my FastAPI application"}\n\n# Build a Docker image\n# docker build -t my-fastapi-app .\n\n# Run the Docker container\n# docker run -p 8000:8000 my-fastapi-app\n```\n```bash\n# Create a Dockerfile\n# touch Dockerfile\n\n# Add the following content to the Dockerfile\nFROM python:3.9-slim\n\n# Set the working directory\nWORKDIR /app\n\n# Copy the requirements file\nCOPY requirements.txt .\n\n# Install the dependencies\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Copy the application code\nCOPY . .\n\n# Expose the port\nEXPOSE 8000\n\n# Run the command to start the development server\nCMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]\n```\n## Exercise: Deploying a FastAPI Application\nDeploy a simple FastAPI application using Docker. The application should have a single endpoint that returns a JSON response.\n### Step 1: Create a FastAPI Application\nCreate a new file called `main.py` and add the following code:\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get("/")\ndef read_root():\n    return {"message": "Welcome to my FastAPI application"}\n```\n### Step 2: Freeze Dependencies\nCreate a new file called `requirements.txt` and add the following content:\n```\nfastapi\nuvicorn\n```\n### Step 3: Create a Dockerfile\nCreate a new file called `Dockerfile` and add the following content:\n```dockerfile\nFROM python:3.9-slim\n\nWORKDIR /app\n\nCOPY requirements.txt .\n\nRUN pip install --no-cache-dir -r requirements.txt\n\nCOPY . .\n\nEXPOSE 8000\n\nCMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]\n```\n### Step 4: Build and Run the Docker Container\nRun the following commands to build and run the Docker container:\n```bash\ndocker build -t my-fastapi-app .\ndocker run -p 8000:8000 my-fastapi-app\n```\n### Step 5: Test the Application\nOpen a web browser and navigate to `http://localhost:8000` to test the application. The application should return a JSON response with the message "Welcome to my FastAPI application".',
    },
  ]);
}
